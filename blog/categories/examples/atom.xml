<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Examples | OSv Blog]]></title>
  <link href="http://osv-io.github.io//github/blog/categories/examples/atom.xml" rel="self"/>
  <link href="http://osv-io.github.io//github/"/>
  <updated>2019-04-20T01:01:48-04:00</updated>
  <id>http://osv-io.github.io//github/</id>
  <author>
    <name><![CDATA[Cloudius Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Riemann - a Clojure Application on OSv]]></title>
    <link href="http://osv-io.github.io//github/blog/2014/04/22/riemann-on-osv/"/>
    <updated>2014-04-22T12:00:00-04:00</updated>
    <id>http://osv-io.github.io//github/blog/2014/04/22/riemann-on-osv</id>
    <content type="html"><![CDATA[<p><strong>By Tzach Livyatan</strong></p>

<p>Clojure applications run on the JVM, so they’re usually simple to run on OSv.  We have <a href="https://github.com/tzach/capstan-example-clojure">hello world in Clojure</a> running, but this time I wanted to port a real, non-toy, Clojure application. I chose <a href="http://riemann.io">Riemann</a>, a widely-used application for aggregating system events (and more).</p>

<p>I used <a href="http://osv.io/capstan/">Capstan</a>, a tool for building and running applications on OSv.  Jump to the end <a href="https://github.com/tzach/riemann">result</a>, or follow the steps I took:</p>

<!-- more -->

<p>Following the Capstan guideline, I added a <a href="https://github.com/tzach/riemann/blob/master/Capstanfile">Capstanfile</a> to the project.  Here are the parts of Capstanfile you need to know about:</p>

<ul>
  <li>Set the base image. In this case I chose a base image with Java (open-jdk)
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base: cloudius/osv-openjdk
</code></pre></div>    </div>
  </li>
  <li>Build the jar file, taking advantage of the <code class="highlighter-rouge">lein uberjar</code> command, which packages the application with all dependencies into one jar file.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    build: lein uberjar
</code></pre></div></div>
<ul>
  <li>Copy the build artifacts to the base image, producing a new image:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>files:
  /riemann.jar: ./target/riemann-0.2.5-SNAPSHOT-standalone.jar
  /riemann.config: ./riemann.config
</code></pre></div>    </div>
  </li>
</ul>

<p>I also copy the config file, which Riemann will look for.</p>

<ul>
  <li>The run command for the VM is executed when the VM starts.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmdline: /java.so -jar /riemann.jar
</code></pre></div>    </div>
  </li>
</ul>

<p>That’s it. Done with the Capstanfile.</p>

<p><strong>Let’s test it!</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;capstan run
WARN [2014-04-13 14:11:22,029] Thread-9 - riemann.core - instrumentation service caught
java.io.IOException: Cannot run program "hostname": error=0, vfork failed
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1041)
	at java.lang.Runtime.exec(Runtime.java:617)
	at clojure.java.shell$sh.doInvoke(shell.clj:116)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
</code></pre></div></div>
<p>No luck.  It turns out that Riemann is using</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(sh "hostname")
</code></pre></div></div>

<p>which uses vfork to run a child process. On any OS its not very efficient to fork just to get the hostname, and on current OSv it simply won’t work. To bypass the problem, I replace this call with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(.getHostName (java.net.InetAddress/getLocalHost))
</code></pre></div></div>
<p>which uses a Java <code class="highlighter-rouge">getHostName</code>.</p>

<p><strong>Let’s try again</strong></p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span>capstan run
</code></pre></div></div>
<p>This time it works, but how do I test it and connect to it?</p>

<p><strong>Let’s use Capstan port forwarding</strong></p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>capstan run <span class="nt">-f</span> 5555:5555 <span class="nt">-f</span> 5556:5556
</code></pre></div></div>
<p>This will  forward host ports 5555 and 5556 to the corresponding ports on the OSv VM.</p>

<p><strong>Success :)</strong></p>

<p>Now we can switch to another terminal and run:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>riemann-health
</code></pre></div></div>
<p>to generate traffic for Riemann
and</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>riemann-dash
</code></pre></div></div>
<p>to launch a Riemann web GUI.  Here is how it looks:</p>

<p><img src="/images/riemann_on_osv.png" alt="&quot;Riemann GUI" /> <i>riemann-dash</i></p>

<p>Now we’re ready to do further stress testing.  If you do find any problem, or have any question, you’re invited to join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev list</a> and ask, or post an issue to the <a href="https://github.com/tzach/riemann">GitHub repository</a>.</p>

<p>— <a href="https://twitter.com/TzachL">Tzach Livyatan</a></p>

]]></content>
  </entry>
  
</feed>
