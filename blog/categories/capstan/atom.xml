<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Capstan | OSv Blog]]></title>
  <link href="http://osv.io/blog/blog/categories/capstan/atom.xml" rel="self"/>
  <link href="http://osv.io/blog/"/>
  <updated>2014-06-23T07:57:20-07:00</updated>
  <id>http://osv.io/blog/</id>
  <author>
    <name><![CDATA[Cloudius Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bridged Networking With Capstan]]></title>
    <link href="http://osv.io/blog/blog/2014/05/07/capstan-bridge/"/>
    <updated>2014-05-07T08:37:05-07:00</updated>
    <id>http://osv.io/blog/blog/2014/05/07/capstan-bridge</id>
    <content type="html"><![CDATA[<p><strong>By Don Marti</strong></p>

<p>New versions of <a href="https://github.com/cloudius-systems/capstan">Capstan</a> are making it simpler to run OSv virtual machines in a production configuration, by adding more control of network options.  A useful new feature, which helps deal with the <a href="https://github.com/cloudius-systems/osv/wiki/Running-OSv-image-under-KVM-QEMU">details of bringing up networking</a>, is the <code>-n</code> option.</p>

<p>By default, Capstan starts up KVM/QEMU with user networking:</p>

<p><code>
 -netdev user,id=un0,net=192.168.122.0/24,host=192.168.122.1
</code></p>

<p>(That&rsquo;s from <code>ps ax | grep qemu</code>, which you can run
to see the qemu-system-x86_64 command that Capstan
is executing for you.)</p>

<p>But there are many more <a href="http://www.linux-kvm.org/page/Networking">networking options</a> for QEMU/KVM.  The basic user networking, which does not require root access to start up, is good for development and simple tasks.  But for production use, where you need to get your VM on a network where it&rsquo;s available from other VMs or from the outside, you&rsquo;ll need bridged networking.  (See your Linux distribution or hypervisor documentation for the details of creating a virtual or public bridge device.)</p>

<p>If you invoke <code>capstan run</code> with the <code>-n bridge</code> option, you&rsquo;ll get QEMU running with:</p>

<p><code>
-netdev bridge,id=hn0,br=virbr0,helper=/usr/libexec/qemu-bridge-helper
</code></p>

<p>If you have a specific bridge device to connect to, you can use the <code>-b</code> option with the name of the bridge device.  The default is <code>virbr0</code>, but you can also set up a public bridge, usually <code>br0</code>, that&rsquo;s bridged to a physical network interface on the host.</p>

<h1>Other hypervisors</h1>

<p>Don&rsquo;t feel left out if you have a different hypervisor.  Capstan also handles bridged networking on VirtualBox, with the rest of the supported hypervisors coming soon.   The fact that the syntax is the same is going to be a big time-saver for those of us who have to do testing and demos on multiple systems&mdash;no more dealing with arcane commands that are different from system to system.</p>

<p>For more on Capstan and networking, please join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev mailing list on Google Groups</a>.  You can get updates by subscribing to this blog&rsquo;s feed, or folllowing <a href="https://twitter.com/CloudiusSystems">@CloudiusSystems</a> on Twitter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Riemann - a Clojure Application on OSv]]></title>
    <link href="http://osv.io/blog/blog/2014/04/22/riemann-on-osv/"/>
    <updated>2014-04-22T09:00:00-07:00</updated>
    <id>http://osv.io/blog/blog/2014/04/22/riemann-on-osv</id>
    <content type="html"><![CDATA[<p><strong>By Tzach Livyatan</strong></p>

<p>Clojure applications run on the JVM, so they&rsquo;re usually simple to run on OSv.  We have <a href="https://github.com/tzach/capstan-example-clojure">hello world in Clojure</a> running, but this time I wanted to port a real, non-toy, Clojure application. I chose <a href="http://riemann.io">Riemann</a>, a widely-used application for aggregating system events (and more).</p>

<p>I used <a href="http://osv.io/capstan/">Capstan</a>, a tool for building and running applications on OSv.  Jump to the end <a href="https://github.com/tzach/riemann">result</a>, or follow the steps I took:</p>

<!-- more -->


<p>Following the Capstan guideline, I added a <a href="https://github.com/tzach/riemann/blob/master/Capstanfile">Capstanfile</a> to the project.  Here are the parts of Capstanfile you need to know about:</p>

<ul>
<li><p>Set the base image. In this case I chose a base image with Java (open-jdk)
<code>
base: cloudius/osv-openjdk
</code></p></li>
<li><p>Build the jar file, taking advantage of the <code>lein uberjar</code> command, which packages the application with all dependencies into one jar file.</p></li>
</ul>


<p>```</p>

<pre><code>build: lein uberjar
</code></pre>

<p><code>
  * Copy the build artifacts to the base image, producing a new image:
</code>
files:
  /riemann.jar: ./target/riemann-0.2.5-SNAPSHOT-standalone.jar
  /riemann.config: ./riemann.config
```</p>

<p>I also copy the config file, which Riemann will look for.</p>

<ul>
<li>The run command for the VM is executed when the VM starts.
<code>
cmdline: /java.so -jar /riemann.jar
</code></li>
</ul>


<p>That&rsquo;s it. Done with the Capstanfile.</p>

<p><strong>Let&rsquo;s test it!</strong>
```</p>

<blockquote><p>capstan run
WARN [2014-04-13 14:11:22,029] Thread-9 &ndash; riemann.core &ndash; instrumentation service caught
java.io.IOException: Cannot run program &ldquo;hostname&rdquo;: error=0, vfork failed</p>

<pre><code>at java.lang.ProcessBuilder.start(ProcessBuilder.java:1041)
at java.lang.Runtime.exec(Runtime.java:617)
at clojure.java.shell$sh.doInvoke(shell.clj:116)
at clojure.lang.RestFn.invoke(RestFn.java:408)
</code></pre>

<p><code>
No luck.  It turns out that Riemann is using
</code>
(sh &ldquo;hostname&rdquo;)
```</p></blockquote>

<p>which uses vfork to run a child process. On any OS its not very efficient to fork just to get the hostname, and on current OSv it simply won&rsquo;t work. To bypass the problem, I replace this call with:</p>

<p><code>
(.getHostName (java.net.InetAddress/getLocalHost))
</code>
which uses a Java <code>getHostName</code>.</p>

<p><strong>Let&rsquo;s try again</strong>
```sh</p>

<blockquote><p>capstan run
```
This time it works, but how do I test it and connect to it?</p></blockquote>

<p><strong>Let&rsquo;s use Capstan port forwarding</strong>
<code>sh
capstan run -f 5555:5555 -f 5556:5556
</code>
This will  forward host ports 5555 and 5556 to the corresponding ports on the OSv VM.</p>

<p><strong>Success :)</strong></p>

<p>Now we can switch to another terminal and run:
<code>sh
riemann-health
</code>
to generate traffic for Riemann
and
<code>sh
riemann-dash
</code>
to launch a Riemann web GUI.  Here is how it looks:</p>

<p><img src="/images/riemann_on_osv.png" alt="&quot;Riemann GUI" /> <i>riemann-dash</i></p>

<p>Now we&rsquo;re ready to do further stress testing.  If you do find any problem, or have any question, you&rsquo;re invited to join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev list</a> and ask, or post an issue to the <a href="https://github.com/tzach/riemann">GitHub repository</a>.</p>

<p>&mdash; <a href="https://twitter.com/TzachL">Tzach Livyatan</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Simple Capstan Example]]></title>
    <link href="http://osv.io/blog/blog/2014/04/03/capstan/"/>
    <updated>2014-04-03T08:37:05-07:00</updated>
    <id>http://osv.io/blog/blog/2014/04/03/capstan</id>
    <content type="html"><![CDATA[<p>(Updated 14 April 2014: Add new URL for osv-base image.)</p>

<p><a href="https://github.com/cloudius-systems/capstan">Capstan</a> is a new tool for building <a href="http://osv.io/">OSv</a> virtual machine images.  If you have worked with other tools for making VMs, you&rsquo;ll find that Capstan is really simple.  It&rsquo;s a lot like <a href="http://www.docker.io/">Docker</a> actually&mdash;only you get a complete VM out of it and not just a container.</p>

<p>You&rsquo;re probably used to blogs from sneaky tech evangelists who claim that something is simple and then post some <a href="http://drusepth.net/how-to-speed-up-your-computer-using-google-drive-as-extra-ram/">complicated set of instructions</a>.  So just to keep your finger off the close button, here&rsquo;s all you need to do.</p>

<ul>
<li><p>Add a Make target to build your application as a shared object.</p></li>
<li><p>Write a short Capstanfile.  (8 lines not counting comments).</p></li>
<li><p>Run Capstan.</p></li>
</ul>


<p>That&rsquo;s all there is to it.  Finger off the close button now?  Good.  Ready?</p>

<!-- more -->


<p>Let&rsquo;s make a VM that does something useful, say, serve this article to the entire Internet.  Go ahead and <code>git clone</code> <a href="https://github.com/cloudius-systems/capstan">Capstan</a> and follow along.</p>

<h2>An easy example, plus Makefile work</h2>

<p>Just to keep it simple, let&rsquo;s borrow the short HTTP server example from <a href="http://libevent.org/">libevent</a>.  The libevent project is a wrapper for convenient event-driven programming, and the library is used in high-profile projects such as <a href="https://www.torproject.org/">Tor</a>, the anonymous communications system, and <a href="http://www.chromium.org/Home">Chromium</a>, the basis for the Google Chrome web browser.</p>

<p>Best of all, libevent includes an easy-to-use HTTP implementation and sample code for using it.  So I&rsquo;ll copy their web server sample code, tweak it a little to make the web server I need, and set up a simple Makefile.</p>

<p>Those steps are all done in the code for this article, which is at <a href="https://github.com/dmarti/http-server">dmarti/http-server</a>.</p>

<p>You&rsquo;ll need the development package for libevent installed.  On my system, it&rsquo;s called <code>libevent-devel</code>.</p>

<p>Here&rsquo;s the target to pay attention to:</p>

<p>```
http-server.so : http-server.c</p>

<pre><code>    $(CC) -o $@ -std=gnu99 -fPIC -shared -levent $``
</code></pre>

<p>```</p>

<p>Yes, that&rsquo;s right, we&rsquo;re using <code>-fPIC</code> (position independent code) and <code>-shared</code> (passed to the linker, make it build a shared library).  And <code>http-server.c</code> has a function called <code>main</code>.  What&rsquo;s going on?  This is because of the way OSv works.  Your application on OSv isn&rsquo;t a conventional ELF executable, but a .so file.</p>

<p>Besides building the actual HTTP server, I&rsquo;ll also put in a Make target to create the HTML version of this article from the README, <a href="https://lwn.net/Articles/589196/">because I can</a>.  So I type <code>make</code> to build the web content and the web server.</p>

<p>Of course you can expand on this to build as complicated of an application and data set as you want.  This is just an example to show you Capstan for now.</p>

<h2>Step two: Add a Capstanfile</h2>

<p>Now it&rsquo;s time to tell Capstan how to create the virtual machine image.  Building it is easy&mdash;just run <code>make</code>&mdash;so there&rsquo;s the <code>build</code> section right there.  Now we need to tell Capstan what files go into the image, so we populate the <code>files</code> section with the name of our web server (http-server.so) the libevent shared library, and some web content&mdash;just the HTML version of this article, plus a favicon.ico file.  (For now I&rsquo;m just copying my development systems&rsquo;s copy of libevent into the image.  For real use, I&rsquo;ll come up with a more consistent way to keep track of build artifacts like this, probably borrowing them from some helpful Linux distribution.  Yes, OSv can use libraries built on and for your 64-bit Linux box.)</p>

<p>Easy so far.  Now for the <code>cmdline</code> option, which is like <a href="http://docs.docker.io/en/v0.6.3/use/builder/#cmd">Docker&rsquo;s CMD</a>: the command that gets run when the image starts.  The HTTP server just takes its DocumentRoot entry from the command line, so the command comes out as:</p>

<p><code>
cmdline: /tools/http-server.so /www
</code></p>

<p>There&rsquo;s one more section in the Capstanfile: <code>base</code>.  That&rsquo;s a pre-built OSv image, which is available from Amazon S3.  Capstan will automatically download this for you.  It lives under <code>.capstan</code> in your home directory.</p>

<h2>Putting it all together</h2>

<p>Now, when we type <code>capstan build</code>, Capstan invokes <code>make</code>, then creates the VM image.  It lives under <code>.capstan</code> in your home directory, at:</p>

<p><code>
.capstan/repository/http-server/http-server.qemu
</code></p>

<p>This is a QCOW2 image, ready to run under KVM or convert to your favorite format.  That&rsquo;s it.  Told you it was simple.  You can just do <code>capstan run</code> and point your browser to <a href="http://localhost:8080/">http://localhost:8080/</a> to see the site.</p>

<p>In an upcoming blog post, I&rsquo;ll cover the recently added VirtualBox support in Capstan (hint: try <code>-p vbox</code>) and some other fun things you can do.</p>

<p>If you have any Capstan questions, please join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev mailing list on Google Groups</a>.  You can get updates on new OSv and Capstan progress by subscribing to this blog or folllowing <a href="https://twitter.com/CloudiusSystems">@CloudiusSystems</a> on Twitter.</p>
]]></content>
  </entry>
  
</feed>
