<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | OSv Blog]]></title>
  <link href="http://osv-io.github.io//github/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://osv-io.github.io//github/"/>
  <updated>2019-04-20T01:01:48-04:00</updated>
  <id>http://osv-io.github.io//github/</id>
  <author>
    <name><![CDATA[Cloudius Systems]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Speed Run: Running 4 Virtual Appliances on Your Laptop in 5 Seconds Overall]]></title>
    <link href="http://osv-io.github.io//github/blog/2014/09/14/how-fast-can-you-run-4-vm/"/>
    <updated>2014-09-14T02:30:00-04:00</updated>
    <id>http://osv-io.github.io//github/blog/2014/09/14/how-fast-can-you-run-4-vm</id>
    <content type="html"><![CDATA[<p><strong>By Dor Laor, Tzach Livyatan</strong></p>

<p>In the following demo, Dor is running 4 different OSv base virtual appliances
on his laptop:</p>

<ul>
  <li>Redis</li>
  <li>Tomcat</li>
  <li>MySQL</li>
  <li>Cassandra</li>
</ul>

<p>Each virtual appliance is a full–blown VM, each with a pre-integrated
cloud application, and each launched without terminating the others.</p>

<!-- more -->

<script type="text/javascript" src="https://asciinema.org/a/11914.js" id="asciicast-11914" async=""></script>

<p>As you can see, application startup time takes between sub-second
(Redis) to a few seconds (Cassandra) depending on the application.
The hypervisor plus OS part of the boot time is less than a second for all cases.</p>

<p>Want more info on Capstan and related topics?  Join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev mailing list</a>.  You can get regular OSv updates by subscribing to this blog’s feed, or folllowing <a href="https://twitter.com/CloudiusSystems">@CloudiusSystems</a> on Twitter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Is the Most Popular OSv Virtual Appliance?]]></title>
    <link href="http://osv-io.github.io//github/blog/2014/07/01/s3stat/"/>
    <updated>2014-07-01T00:00:00-04:00</updated>
    <id>http://osv-io.github.io//github/blog/2014/07/01/s3stat</id>
    <content type="html"><![CDATA[<p><strong>By Tzach Livyatan</strong></p>

<p>(Spoiler: It’s Apache Tomcat.)</p>

<p><a href="https://github.com/cloudius-systems/capstan">Capstan</a> is a tool for rapidly building and running applications on OSv.
As with Docker, Capstan users can download and run images from a public repository.
We chose to implement our public Capstan repository using <a href="http://aws.amazon.com/s3/">Amazon S3</a>.</p>

<p>Amazon S3  gives us the flexibility and security we need, but by default it’s missing a critical feature: download statistics.
This statistics are very interesting to us, to evaluate which of the Capstan virtual appliances are more popular.  Fortunately, there is an easy way to gather the stats we need.</p>

<p>After a short tools survey, we choose <a href="http://www.s3stat.com/">s3stat</a>.</p>

<p><a href="http://www.s3stat.com/">s3stat</a> is a cloud-based service which can follow an S3 bucket, and visualize download statistics, by file, country, browser day, or otherwise.
The price makes sense, and it is super easy to enable.</p>

<p><img src="/images/s3stat_chart.png" alt="s3stat chart" /></p>

<p>So what are the results? (drum roll….) 
<!-- more -->
<img src="/images/s3stat_files.png" alt="s3stat files" /></p>

<p>Omitting Capstan download of capstan index.yaml files, which Capstan does for every repository search, the most popular images are the base images for OSv and OSv + Java.
That make sense because these two images will be used by anyone who wants to build a local OSv application, running a native or Java application.</p>

<p>Virtual appliances comes right after, with (drums again….) <strong>Tomcat</strong>, <strong>Cassandra</strong>, <strong>Memcached</strong> on the podium (Tomcat wins the Gold).
These are all very early results, but we will keep using s3stat to follow Capstan image downloads.</p>

<p><img src="/images/s3stat_map.png" alt="s3stat map" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bridged Networking With Capstan]]></title>
    <link href="http://osv-io.github.io//github/blog/2014/05/07/capstan-bridge/"/>
    <updated>2014-05-07T11:37:05-04:00</updated>
    <id>http://osv-io.github.io//github/blog/2014/05/07/capstan-bridge</id>
    <content type="html"><![CDATA[<p><strong>By Don Marti</strong></p>

<p>New versions of <a href="https://github.com/cloudius-systems/capstan">Capstan</a> are making it simpler to run OSv virtual machines in a production configuration, by adding more control of network options.  A useful new feature, which helps deal with the <a href="https://github.com/cloudius-systems/osv/wiki/Running-OSv-image-under-KVM-QEMU">details of bringing up networking</a>, is the <code class="highlighter-rouge">-n</code> option.</p>

<p>By default, Capstan starts up KVM/QEMU with user networking:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> -netdev user,id=un0,net=192.168.122.0/24,host=192.168.122.1
</code></pre></div></div>

<p>(That’s from <code class="highlighter-rouge">ps ax | grep qemu</code>, which you can run
to see the qemu-system-x86_64 command that Capstan
is executing for you.)</p>

<p>But there are many more <a href="http://www.linux-kvm.org/page/Networking">networking options</a> for QEMU/KVM.  The basic user networking, which does not require root access to start up, is good for development and simple tasks.  But for production use, where you need to get your VM on a network where it’s available from other VMs or from the outside, you’ll need bridged networking.  (See your Linux distribution or hypervisor documentation for the details of creating a virtual or public bridge device.)</p>

<p>If you invoke <code class="highlighter-rouge">capstan run</code> with the <code class="highlighter-rouge">-n bridge</code> option, you’ll get QEMU running with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-netdev bridge,id=hn0,br=virbr0,helper=/usr/libexec/qemu-bridge-helper
</code></pre></div></div>

<p>If you have a specific bridge device to connect to, you can use the <code class="highlighter-rouge">-b</code> option with the name of the bridge device.  The default is <code class="highlighter-rouge">virbr0</code>, but you can also set up a public bridge, usually <code class="highlighter-rouge">br0</code>, that’s bridged to a physical network interface on the host.</p>

<h1 id="other-hypervisors">Other hypervisors</h1>

<p>Don’t feel left out if you have a different hypervisor.  Capstan also handles bridged networking on VirtualBox, with the rest of the supported hypervisors coming soon.   The fact that the syntax is the same is going to be a big time-saver for those of us who have to do testing and demos on multiple systems—no more dealing with arcane commands that are different from system to system.</p>

<p>For more on Capstan and networking, please join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev mailing list on Google Groups</a>.  You can get updates by subscribing to this blog’s feed, or folllowing <a href="https://twitter.com/CloudiusSystems">@CloudiusSystems</a> on Twitter.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Riemann - a Clojure Application on OSv]]></title>
    <link href="http://osv-io.github.io//github/blog/2014/04/22/riemann-on-osv/"/>
    <updated>2014-04-22T12:00:00-04:00</updated>
    <id>http://osv-io.github.io//github/blog/2014/04/22/riemann-on-osv</id>
    <content type="html"><![CDATA[<p><strong>By Tzach Livyatan</strong></p>

<p>Clojure applications run on the JVM, so they’re usually simple to run on OSv.  We have <a href="https://github.com/tzach/capstan-example-clojure">hello world in Clojure</a> running, but this time I wanted to port a real, non-toy, Clojure application. I chose <a href="http://riemann.io">Riemann</a>, a widely-used application for aggregating system events (and more).</p>

<p>I used <a href="http://osv.io/capstan/">Capstan</a>, a tool for building and running applications on OSv.  Jump to the end <a href="https://github.com/tzach/riemann">result</a>, or follow the steps I took:</p>

<!-- more -->

<p>Following the Capstan guideline, I added a <a href="https://github.com/tzach/riemann/blob/master/Capstanfile">Capstanfile</a> to the project.  Here are the parts of Capstanfile you need to know about:</p>

<ul>
  <li>Set the base image. In this case I chose a base image with Java (open-jdk)
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>base: cloudius/osv-openjdk
</code></pre></div>    </div>
  </li>
  <li>Build the jar file, taking advantage of the <code class="highlighter-rouge">lein uberjar</code> command, which packages the application with all dependencies into one jar file.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    build: lein uberjar
</code></pre></div></div>
<ul>
  <li>Copy the build artifacts to the base image, producing a new image:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>files:
  /riemann.jar: ./target/riemann-0.2.5-SNAPSHOT-standalone.jar
  /riemann.config: ./riemann.config
</code></pre></div>    </div>
  </li>
</ul>

<p>I also copy the config file, which Riemann will look for.</p>

<ul>
  <li>The run command for the VM is executed when the VM starts.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmdline: /java.so -jar /riemann.jar
</code></pre></div>    </div>
  </li>
</ul>

<p>That’s it. Done with the Capstanfile.</p>

<p><strong>Let’s test it!</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;capstan run
WARN [2014-04-13 14:11:22,029] Thread-9 - riemann.core - instrumentation service caught
java.io.IOException: Cannot run program "hostname": error=0, vfork failed
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1041)
	at java.lang.Runtime.exec(Runtime.java:617)
	at clojure.java.shell$sh.doInvoke(shell.clj:116)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
</code></pre></div></div>
<p>No luck.  It turns out that Riemann is using</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(sh "hostname")
</code></pre></div></div>

<p>which uses vfork to run a child process. On any OS its not very efficient to fork just to get the hostname, and on current OSv it simply won’t work. To bypass the problem, I replace this call with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(.getHostName (java.net.InetAddress/getLocalHost))
</code></pre></div></div>
<p>which uses a Java <code class="highlighter-rouge">getHostName</code>.</p>

<p><strong>Let’s try again</strong></p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span>capstan run
</code></pre></div></div>
<p>This time it works, but how do I test it and connect to it?</p>

<p><strong>Let’s use Capstan port forwarding</strong></p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>capstan run <span class="nt">-f</span> 5555:5555 <span class="nt">-f</span> 5556:5556
</code></pre></div></div>
<p>This will  forward host ports 5555 and 5556 to the corresponding ports on the OSv VM.</p>

<p><strong>Success :)</strong></p>

<p>Now we can switch to another terminal and run:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>riemann-health
</code></pre></div></div>
<p>to generate traffic for Riemann
and</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>riemann-dash
</code></pre></div></div>
<p>to launch a Riemann web GUI.  Here is how it looks:</p>

<p><img src="/images/riemann_on_osv.png" alt="&quot;Riemann GUI" /> <i>riemann-dash</i></p>

<p>Now we’re ready to do further stress testing.  If you do find any problem, or have any question, you’re invited to join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev list</a> and ask, or post an issue to the <a href="https://github.com/tzach/riemann">GitHub repository</a>.</p>

<p>— <a href="https://twitter.com/TzachL">Tzach Livyatan</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Simple Capstan Example]]></title>
    <link href="http://osv-io.github.io//github/blog/2014/04/03/capstan/"/>
    <updated>2014-04-03T11:37:05-04:00</updated>
    <id>http://osv-io.github.io//github/blog/2014/04/03/capstan</id>
    <content type="html"><![CDATA[<p>(Updated 14 April 2014: Add new URL for osv-base image.)</p>

<p><a href="https://github.com/cloudius-systems/capstan">Capstan</a> is a new tool for building <a href="http://osv.io/">OSv</a> virtual machine images.  If you have worked with other tools for making VMs, you’ll find that Capstan is really simple.  It’s a lot like <a href="http://www.docker.io/">Docker</a> actually—only you get a complete VM out of it and not just a container.</p>

<p>You’re probably used to blogs from sneaky tech evangelists who claim that something is simple and then post some <a href="http://drusepth.net/how-to-speed-up-your-computer-using-google-drive-as-extra-ram/">complicated set of instructions</a>.  So just to keep your finger off the close button, here’s all you need to do.</p>

<ul>
  <li>
    <p>Add a Make target to build your application as a shared object.</p>
  </li>
  <li>
    <p>Write a short Capstanfile.  (8 lines not counting comments).</p>
  </li>
  <li>
    <p>Run Capstan.</p>
  </li>
</ul>

<p>That’s all there is to it.  Finger off the close button now?  Good.  Ready?</p>

<!-- more -->

<p>Let’s make a VM that does something useful, say, serve this article to the entire Internet.  Go ahead and <code class="highlighter-rouge">git clone</code> <a href="https://github.com/cloudius-systems/capstan">Capstan</a> and follow along.</p>

<h2 id="an-easy-example-plus-makefile-work">An easy example, plus Makefile work</h2>

<p>Just to keep it simple, let’s borrow the short HTTP server example from <a href="http://libevent.org/">libevent</a>.  The libevent project is a wrapper for convenient event-driven programming, and the library is used in high-profile projects such as <a href="https://www.torproject.org/">Tor</a>, the anonymous communications system, and <a href="http://www.chromium.org/Home">Chromium</a>, the basis for the Google Chrome web browser.</p>

<p>Best of all, libevent includes an easy-to-use HTTP implementation and sample code for using it.  So I’ll copy their web server sample code, tweak it a little to make the web server I need, and set up a simple Makefile.</p>

<p>Those steps are all done in the code for this article, which is at <a href="https://github.com/dmarti/http-server">dmarti/http-server</a>.</p>

<p>You’ll need the development package for libevent installed.  On my system, it’s called <code class="highlighter-rouge">libevent-devel</code>.</p>

<p>Here’s the target to pay attention to:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http-server.so : http-server.c
        $(CC) -o $@ -std=gnu99 -fPIC -shared -levent $``
</code></pre></div></div>

<p>Yes, that’s right, we’re using <code class="highlighter-rouge">-fPIC</code> (position independent code) and <code class="highlighter-rouge">-shared</code> (passed to the linker, make it build a shared library).  And <code class="highlighter-rouge">http-server.c</code> has a function called <code class="highlighter-rouge">main</code>.  What’s going on?  This is because of the way OSv works.  Your application on OSv isn’t a conventional ELF executable, but a .so file.</p>

<p>Besides building the actual HTTP server, I’ll also put in a Make target to create the HTML version of this article from the README, <a href="https://lwn.net/Articles/589196/">because I can</a>.  So I type <code class="highlighter-rouge">make</code> to build the web content and the web server.</p>

<p>Of course you can expand on this to build as complicated of an application and data set as you want.  This is just an example to show you Capstan for now.</p>

<h2 id="step-two-add-a-capstanfile">Step two: Add a Capstanfile</h2>

<p>Now it’s time to tell Capstan how to create the virtual machine image.  Building it is easy–just run <code class="highlighter-rouge">make</code>–so there’s the <code class="highlighter-rouge">build</code> section right there.  Now we need to tell Capstan what files go into the image, so we populate the <code class="highlighter-rouge">files</code> section with the name of our web server (http-server.so) the libevent shared library, and some web content–just the HTML version of this article, plus a favicon.ico file.  (For now I’m just copying my development systems’s copy of libevent into the image.  For real use, I’ll come up with a more consistent way to keep track of build artifacts like this, probably borrowing them from some helpful Linux distribution.  Yes, OSv can use libraries built on and for your 64-bit Linux box.)</p>

<p>Easy so far.  Now for the <code class="highlighter-rouge">cmdline</code> option, which is like <a href="http://docs.docker.io/en/v0.6.3/use/builder/#cmd">Docker’s CMD</a>: the command that gets run when the image starts.  The HTTP server just takes its DocumentRoot entry from the command line, so the command comes out as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmdline: /tools/http-server.so /www
</code></pre></div></div>

<p>There’s one more section in the Capstanfile: <code class="highlighter-rouge">base</code>.  That’s a pre-built OSv image, which is available from Amazon S3.  Capstan will automatically download this for you.  It lives under <code class="highlighter-rouge">.capstan</code> in your home directory.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>Now, when we type <code class="highlighter-rouge">capstan build</code>, Capstan invokes <code class="highlighter-rouge">make</code>, then creates the VM image.  It lives under <code class="highlighter-rouge">.capstan</code> in your home directory, at:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.capstan/repository/http-server/http-server.qemu
</code></pre></div></div>

<p>This is a QCOW2 image, ready to run under KVM or convert to your favorite format.  That’s it.  Told you it was simple.  You can just do <code class="highlighter-rouge">capstan run</code> and point your browser to <a href="http://localhost:8080/">http://localhost:8080/</a> to see the site.</p>

<p>In an upcoming blog post, I’ll cover the recently added VirtualBox support in Capstan (hint: try <code class="highlighter-rouge">-p vbox</code>) and some other fun things you can do.</p>

<p>If you have any Capstan questions, please join the <a href="https://groups.google.com/forum/#!forum/osv-dev">osv-dev mailing list on Google Groups</a>.  You can get updates on new OSv and Capstan progress by subscribing to this blog or folllowing <a href="https://twitter.com/CloudiusSystems">@CloudiusSystems</a> on Twitter.</p>

]]></content>
  </entry>
  
</feed>
